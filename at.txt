üîÑ REDIS INTEGRATION F√úR AUTOTRADING BACKEND - DRINGEND

Hallo! Das Frontend kommuniziert jetzt √ºber Redis mit dem Backend. Bitte implementiere die Redis-Integration:

üìã REDIS KEYS DIE DAS FRONTEND SCHREIBT:

```redis
# Wenn AutoTrading aktiviert wird:
autotrading:enabled = {
    "enabled": true,
    "buy_threshold_pct": 0.05,
    "sell_threshold_pct": 0.05,
    "max_position_per_trade": 1,
    "strategy": "CONSERVATIVE",
    "timestamp": "2025-09-26T13:15:30.123Z",
    "source": "frontend_ui",
    "market_hours_check": true,
    "session_id": "frontend_1727354130123",
    "trading_hours": {
        "market_open": "09:30",
        "market_close": "16:00", 
        "timezone": "America/New_York"
    }
}

autotrading:status = "ACTIVE"
autotrading:timestamp = "2025-09-26T13:15:30.123Z"

# Wenn AutoTrading gestoppt wird:
DEL autotrading:enabled
autotrading:status = "STOPPED"
autotrading:stopped_at = "2025-09-26T16:00:00.000Z"
```

üéØ BACKEND AUFGABEN:

1. Redis Monitoring Loop:
   ```python
   import redis
   import json
   import threading
   
   def monitor_autotrading():
       r = redis.Redis(host='localhost', port=6380, password='pass123')
       
       while True:
           try:
               # Check for AutoTrading commands
               if r.exists('autotrading:enabled'):
                   config = json.loads(r.get('autotrading:enabled'))
                   if config['enabled'] and config['source'] == 'frontend_ui':
                       # START AUTOTRADING
                       start_autotrading_with_config(config)
               
               elif r.get('autotrading:status') == b'STOPPED':
                   # STOP AUTOTRADING  
                   stop_all_autotrading()
                   
           except Exception as e:
               print(f"Redis monitoring error: {e}")
           
           time.sleep(5)  # Check every 5 seconds
   ```

2. Market Hours Integration:
   - Config enth√§lt `trading_hours` und `market_hours_check: true`
   - Backend soll auch nochmal Marktzeiten pr√ºfen
   - Bei geschlossenem Markt: AutoTrading pausieren

3. Status Feedback:
   ```python
   # Backend schreibt Status zur√ºck:
   r.set('autotrading:backend_status', 'RUNNING')
   r.set('autotrading:last_trade', json.dumps(trade_info))
   r.set('autotrading:active_positions', json.dumps(positions))
   ```

4. Session Management:
   - `session_id` vom Frontend beachten
   - Nur eine AutoTrading Session gleichzeitig
   - Bei neuem `session_id`: alte Session stoppen

üîß REDIS CONNECTION:
- Host: localhost (oder Docker internal IP)  
- Port: 6380
- Password: pass123

üè¶ BROKER INTEGRATION - ERFORDERLICH F√úR ECHTE TRADES:

F√ºr echtes Trading muss das Backend zus√§tzlich implementieren:

1. BROKER API CONNECTION:
   ```python
   # Beispiel f√ºr Interactive Brokers:
   from ib_insync import IB, Stock, MarketOrder
   
   def connect_to_broker():
       ib = IB()
       ib.connect('127.0.0.1', 7497, clientId=1)  # TWS Paper: 7497, Live: 7496
       return ib
   
   def place_real_order(symbol, quantity, action):
       ib = connect_to_broker()
       contract = Stock(symbol, 'SMART', 'USD')
       order = MarketOrder(action, quantity)
       trade = ib.placeOrder(contract, order)
       return trade
   ```

2. ECHTE MARKTDATEN:
   ```python
   # Echte Preise statt Simulation
   def get_real_price(symbol):
       # Von Broker API oder Marktdaten-Feed
       ticker = ib.reqMktData(contract)
       return ticker.last
   ```

3. ECHTES PORTFOLIO:
   ```python
   # Echte Positionen laden
   def get_real_positions():
       positions = ib.positions()
       return [{
           'symbol': pos.contract.symbol,
           'quantity': pos.position,
           'market_value': pos.marketValue,
           'unrealized_pnl': pos.unrealizedPNL
       } for pos in positions]
   ```

üö® KRITISCHE SICHERHEIT:
- Testze ZUERST mit Paper Trading Account!
- Kleine Positionsgr√∂√üen f√ºr erste Tests
- Stop-Loss Limits implementieren
- Maximale Verlustgrenzen setzen

üö® WICHTIG:
- Frontend startet AutoTrading ‚Üí Redis Key wird gesetzt
- Backend MUSS kontinuierlich Redis √ºberwachen
- Bei `autotrading:enabled` ‚Üí echtes Trading starten
- Bei `DEL autotrading:enabled` ‚Üí sofort stoppen

üìç TIMELINE:
Das Frontend ist bereits fertig und schreibt in Redis. Backend muss jetzt die Keys lesen und entsprechend handeln.

Kannst du das Redis Monitoring und die AutoTrading Steuerung implementieren?